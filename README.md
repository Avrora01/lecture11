# lecture11
> **Асинхронность** – это способ координации поведения программы на протяжении какого-то временного отрезка. Разбираем, как в синхронном JavaScript вынести операции за рамки единого потока, чтобы не блокировать действие кода после тяжёлых операций. 
**JavaScript** – это однопоточный язык программирования. JS исполняет одну строку кода в одну единицу времени и не предполагает мультитаскинга. Это отличает JS от многопоточного Java, например, где можно создавать отдельные потоки и переносить новый код в отдельно созданный поток.

> В JS при выполнении какой-то одной тяжелой операции, весь код, который следует после неё, может заморозиться. То есть скрипт блокируется, и страница, на которой в данный момент времени этот скрипт используется, становится неотзывчивой.

Поскольку все операции проходят в одном потоке, ряд операций можно сделать асинхронными и вынести за рамки единого потока, чтобы не блокировать дальнейшее исполнение кода. Для этого могут использоваться коллбэки, промисы и асинхронные функции, но в современном JavaScript на практике используются только промисы и асинхронные функции.

Для понимания асинхронности недостаточно знать только core JavaScript. Движок JS состоит из трех основных частей:

 - поток выполнения;
 - память/переменная среда;
 - стек вызовов.

>Web **API** хранит в себе асинхронные операции и не является частью движка JS, но предоставляет окружение, набор API, предоставляемых движку JS для его взаимодействия с вебом. На схеме для примера изображены 4 сегмента **API,** но на деле их может быть неограниченное множество. 

# Promises
Большая часть нашего кода JavaScript выполняется с помощью функций браузера, но у нас нет доступа к скрытому в его глубине бекенду. Новая возможность ES6 обещает помочь получить некоторую согласованность между происходящим в фоновом режиме и нашей фактической памятью JavaScript, чтобы обрабатывать результат. В ES5 использовалась fetch/xhr для получения сетевого запроса, но это не влияло на фактическую память. С введением промисов fetch должна совершать сетевой запрос и возвращать объект Promise, который будет находиться в памяти. Как только запрос выполнится, объект будет заполнен данными из него.

Промисы можно лучше понять, опираясь на два подхода. Первый указывает на выполняемые через функции браузера фоновые процессы, а второй является отслеживающим запросом объекта Promise в памяти.

Использование этих двух подходов поможет сделать следующее:

- инициировать фоновую работу веб-браузера;
- немедленно возвратить объект-заполнитель (promise) в JavaScript.
        
function display(data)   
{   
  console.log(data);   
}   
const futureData = fetch('https//somelink.com');  
futureData.then(display);  
console.log('Me first');

Функция fetch – одна из важных функций JS. С ее помощью устанавливается объект Promise в памяти JS. Он имеет два свойства: **value,** в котором хранятся данные ответа, и **onFulfilled,** который является пустым массивом.

# async/await в JavaScript:

>Конструкция async/await сделала большой вклад в асинхронное JS-программирование: можно использовать стиль синхронного кода для асинхронного

Плюсы async/await
Существенным плюсом async/await является возможность использования синхронного стиля программирования. Пример:

***// async/await *** 
async getBooksByAuthorWithAwait(authorId) {  
  const books = await bookModel.fetchAll();  
  return books.filter(b => b.authorId ===   authorId);  
}  
***// promise  ***  
getBooksByAuthorWithPromise(authorId) {  
  return bookModel.fetchAll()  
    .then(books => books.filter(b =>authorId=== authorId));
}

Очевидно, что код с использованием данной конструкции гораздо проще чем тот, что создан с помощью promise. Если игнорировать await, программу не отличить от любого другого синхронного языка, 

Иногда сравнение с promise сопровождается утверждением, будто это эволюция асинхронного JS-программирования, что довольно спорно. async/await – лишь “приправа” для вашего кода, его небольшой апдейт, и никак не изменит ваш стиль программирования полностью.

По сути, promise – это как раз те самые асинхронные функции. Чтобы их юзать, нужно сперва хорошо разобраться с promise. Его все же придется использовать чаще.

Хоть await и может синхронизировать код, имейте в виду, что он по-прежнему является асинхронным. Поэтому необходимо позаботиться о том, чтобы он не был слишком последовательным.

async getBooksAndAuthor(authorId) {   
  const books = await bookModel.fetchAll();   
  const author = await authorModel.fetch(authorId);    
  return {   
    author,   
    books: books.filter(book => book.authorId ===       authorId),  
  };
}

> **Fetch()**  
Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхрониний

**axios**   
Axios-этоHTTP-клиент, основанный наPromise дляnode.js и браузера. Он может работать вбраузере иnode.js с той же базой кодов.

**const postCreate = async () =>    
{ try {   
  const { data } = await axios.get  (`url`) }   catch (error) 
  {
}
}**
